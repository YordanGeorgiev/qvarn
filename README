README for Tilaajavastuu Unified API backend
============================================

This source tree contains an implementation of the "Unified API" for
the services provided by Suomen Tilaajavastuu Oy. For details of the
API, see the "Tilaajavastuu backend API" (`dev-team-docs.git` on the
company git server; document name is
`unified-api-doc/unified-api-doc.pdf`).

This README contains an introduction to the code, aimed at the people
who develop and/or deploy the code.


Development environment
-----------------------

You need various tools to develop and/or run the software. It's
easiest to do this on Debian (version 7.x, code name wheezy). It may
be possible to run the code in other environments (if so, please add
details here).

* [CoverageTestRunner][], a Python unit test runner for running the
  unit tests. Note that `nose-tests` is insufficient (it'll run, but
  won't check coverage diligently enough). Debian package is
  `python-coverage-test-runner`.
* [pep8][] and [pylint][] static checkers for Python code. (Debian
  packages have those names.)
* [flup][], an implementation of the Python Web Server Gateway
  Interface. Debian package is `python-flup`.

[CoverageTestRunner]: http://liw.fi/coverage-test-runner/
[coverage.py]: http://nedbatchelder.com/code/coverage/
[pep8]: http://pypi.python.org/pypi/pep8
[pylint]: http://www.pylint.org/
[flup]: http://www.saddi.com/software/flup/

The code uses the [bottle.py][] framework for web applications.
However, since the code targets Python 7.x, which has an ancient
version, version 0.12 of bottle.py is embedded in the source tree
(`unifieadpi/bottle.py`).

[bottle.py]: http://bottlepy.org/docs/dev/index.html


Building and running unit tests
-------------------------------

The code is pure Python, and as such does not need building. However,
the `./check` script runs unit tests, and the static Python checkers
`pep8` and `pylint`.

Before merging into the integration branch, `./check` must pass.


Integration tests
-----------------

The API document contains integration tests ("yarns"). These are run
from the `dev-team-docs/unified-api-doc` directory. These can be run
manually:

* Start one of the backend applications, such as `src/persons`:

        PYTHONPATH=. src/persons --host 127.0.0.1 --port 12765 \
            --database persons.db

* Run the relevant scenario for that backend application:

        yarn -s yarn.sh --env API_URL=http://localhost:12765 \
            <(sed '/^ *EXAMPLE/,/^ *$/d' *.yarn) \
            --run "manage a person" -v

    where `manage a person` is the scenario for testing `/persons` in
    the API.

(Someone should write a shell script to wrap the above yarn invocation
so it's easier to run.)


Writing unit tests
------------------

Unit tests are run using `CoverageTestRunner` module, written by Lars
Wirzenius. It can be found at <http://liw.fi/coverage-test-runner/>.
This test runner uses [coverage.py][] to measure test coverage, and
measures a code module's coverage only when its own test module is
run. Coverage for `unifieadpi/foo.py` is only measured when
`unifiedapi/foo_tests.py` is run. Also, the test runner fails the test
suite unless all statements are either covered by tests, or explicitly
marked as excluded from coverage, using a comment such as the
following:

    # Justification for exclusion from coverage: The following thing
    # is obviously correct, but it's difficult to make a good test
    # case for it.
    if very_difficult_condition:  # pragma: no cover
        this_is_not_measured()

Note that you should always include a justification for a pragma.
Otherwise code reviewers and developers in the future who need to look
at the code will assume you're lazy.

If an entire module is going to be without unit tests, it should be
added to the `without-tests` file at the root of the source tree.
`CoverageTestRunner` will then not complain that there are no tests
for it.

When writing or changing code, it's easy to achieve 100% statement
coverage if using TDD, writing one test at a time, and ensuring
coverage never drops.

`CoverageTestRunner` and `coverage.py` are both packaged for Debian.


Coding style
------------

Code must be formatted according to [PEP8][]. The `./check` script
runs a tool to check for many formatting and other style details.

[PEP8]: https://www.python.org/dev/peps/pep-0008/

Code must be kept clean. The `./check` script runs `pylint` to check
for many mistakes; it can also find some actual errors, such as
missing parameters. However, `pylint` is sometimes over-eager in its
checks, and so `./check` turns off some warnings. The script documents
the reasons for those.

Any strings that are meant for containing text, both literals and
values, MUST be Unicode strings. That means literals should be in the
form of `u'this is Unicode'`, with the leading `u`.


Continuous integration and delivery pipeline
--------------------------------------------

A continuous integration and delivery pipeline has been developed and
using it to develop this backend is almost certainly a good idea. See
the "Continuous Delivery Pipeline" (`cd-pipeline`) document in the
`dev-team-docs.git` repository for details.

Running things through the CI/CD pipeline takes time, and failures can
be harder to debug. As much as possible, changes should be developed
and tested in the development environment first, running things
manually. This keeps the inner loop of development short, and does not
require gaining access to the pipeline's test machines.


Implementation architecture
---------------------------

The backend is structured as several independent backend applications,
one per top level resource in the API: `/version`, `/persons`,
`/orgs`, etc. Each backend application is a separate web service.

The various applications share as much code as possible, via the
`unifiedapi` Python library. The library provides the following major
classes:

* `BackendApplication` --- the main program of the application:
  command line parsing, starting of the HTTP server. This class is
  parameterised, not subclassed. The main parameters are the resource
  to serve, and the the routes that the resource provides.

* `ListResource`, `SimpleResource` --- classes to provide the two
  kinds of resources. `ListResource` provides code for resources that
  manage a set of items (such as persons or organisations). Such
  resources are mostly identical to each other, except for details
  such as item type and allowed fields. `SimpleResource` provides for
  simpler resources such as `/version`. Both these classes are
  parameterised, instead of subclassed.

* `Database` --- all the code talking directly to the database; this
  provides a fairly light abstraction providing only the functionality
  we use (or are meant to use).

* `ReadOnlyStorage`, `WriteOnlyStorage` --- store and retrieve simple
  Python dictionary objects representing the kinds of items that the
  API deal with. Basically, these are very trivial ORMs that map
  JSON-like Python objects into rows in relation databases. Reading
  and writing are kept explicitly separate to implement an
  architecture where writes all go into one database instance, which
  gets replicated to any number of read-only databases. By keeping the
  classes separate, it is slightly difficult to accidentally write to
  the wrong place.

* `StoragePreparer` --- manage database schemas and migrations. The
  class maintains a sequence of preparation steps. Every time we make
  a schema change, we add another step, which makes the relevant
  changes: adds or removes tables or columns, and fills new columns
  and tables with the correct data. Every database instance goes
  through the same sequence, even if it is brand new. This should
  guarantee we can always migrate to a newer version, with minimal
  manual intervention.

* `ItemValidator` --- validate that an API item (JSON-like Python
  object) is at least minimally valid. This happens by matching the
  item against a prototype item, and making sure all fields are there,
  and have values of the right type. This parameterised class provides
  generic validation; additional validation is then applied per item
  type, as needed.

In addition, there are a few auxiliary classes and functions. For the
full details, please read the source code and embedded docstrings. (If
the code too hard to read, that's a bug that needs fixing.)


On databases
------------

We have a simple approach to databases. They are used as stupid
storage with lookup. We do not use constraints, triggers, stored
functions, or other database smarts, because such things are harder to
understand and to verify than real code. We also don't do complicated
lookups with SELECT statements: no joins, for example. The `Database`
class reflects this, as does the overall system architecture, which
has been designed to not need much intelligence from the database
layer.


Source code layout
------------------

Most of the code is in the `unifiedapi` library. This library is unit
tested. The backend applications are in the `src` directory. The
application files are kept as small as possible, putting as much code
into the library as possible so that as much code as possible has unit
tests.

The `debian` directory has the files needed to build Debian (`.dsc`
and `.deb`) packages.


Building Debian packages
------------------------

You need to build Debian packages in a Debian system (or a system
sufficiently like Debian; Ubuntu probably works). You need at least
the following packages installed:

* `build-essential` --- all the basic development tools, such as C and
  C++ compilers and development libraries
* `debhelper` --- a packaging helper utility, which makes packaging
  much easier
* `python-all` --- all Python versions (packaging is a little simpler
  if they're all installed)
* `devscripts` --- supplies the `dch` and `debuild` tools.

(This list may be inadequate. If you notice a problem, please change
the list.)

Make sure the `DEBEMAIL` environment variable holds your e-mail
address (`foo.bar@tilaajavastuu.fi`). Set it in your `.bashrc` or
other suitable place.

To prepare and build Debian packages:

1. If you've made any changes, update `debian/changelog`:

    1. `dch -v X.Y-Z This is a summary of my change.` (where X.Y-Z is
       the new version number).
    2. `dch -r ''` (replaces UNRELEASED in the first line).

1. `debuild -us -uc` (the options prevent digital signatures from
   being created).


A deployed system
-----------------

The deployed system, as installed from the Debian package, looks like
this:

* The Python library `unifiedapi` is installed in the usual location
  for such, in Debian: `/usr/lib/python2.7/dist-packages/unifiedapi`.

* The backend applications are installed in
  `/usr/lib/unified-api-backend`.

* The backend applications are started by the `lighttpd`
  configuration. The configuration is in the
  `/etc/lighttpd/conf-available/50-unified-api-backend.conf` file.
  Each application is available on the localhost interface, on its own
  port.

* The `haproxy` load balancer is used to direct HTTP requests from the
  external network interface to the right localhost port. The
  `haproxy` config is put in
  `/var/lib/unified-api-backend/haproxy.cfg` at package install time,
  generated from `/etc/haproxy/haproxy.cfg` and
  `/usr/share/unified-api-backend/haproxy.cfg.snippet` (the latter
  provided by the package itself).

* The SQLite database used by the backend applications are stored in
  `/var/lib/unified-api-backend/storage`, one file per applications.

* There are several log files involved:

    - `/var/log/haproxy.log`
    - `/var/log/lighttpd/error.log`
    - `/var/log/unified-api-backend/foo.log` for backend application
      `foo`
    - `/var/log/unified-api-backend/foo.start.log` for **starting** of
      backend application `foo`, that is, errors from startup, before
      the application gets as far as logging things itself

* All services run as the `www-data` user and `www-data` group.
